# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculating binned matrix product
#'
#' This function calculates the matrix product using Algorithm 3 of Zheyuan Li, Simon N. Wood: "Faster
#' model matrix crossproducts for large generalized linear models with discretized covariates". The idea
#' is to compute just on the unique rows of X by also using an index vector to map to the original matrix.
#' The algorithm implemented here is a small adaption of the original algorithm. Instead of calculating $XW$
#' which again, needs to be transposed, we directly calculate $X^TW$ to avoid another transposing step.
#'
#' @param X [\code{arma::mat}]\cr
#'   Matrix X.
#' @param k [\code{arma::uvec}]\cr
#'   Index vector for mapping to original matrix $X_o(i,) = X(k(i),.)$.
#' @param w [\code{arma::vec}]\cr
#'   Vector of weights that are accumulated.
#' @param use_fast_acc [\code{bool}]\cr
#'   Flag to indicate whether to use the original or adopted algorithm.
#' @return \code{arma::mat} Matrix Product $X^TWX$.
#' @examples
#' nsim = 1e6L
#' nunique = trunc(sqrt(nsim))
#'
#' xunique = runif(n = nunique, min = 0, max = 10)
#' k = sample(x = seq_len(nunique), size = nsim, replace = TRUE)
#'
#' X = poly(x = xunique, degree = 20L)
#'
#' binnedMatMult(X = X, k = k-1, w = 1)
#' @export
binnedMatMult <- function(X, k, w, use_fast_acc = FALSE) {
    .Call(`_cpsp_binnedMatMult`, X, k, w, use_fast_acc)
}

#' Calculating binned matrix product for response term
#'
#' This function calculates the matrix product using Algorithm 3 of Zheyuan Li, Simon N. Wood: "Faster
#' model matrix crossproducts for large generalized linear models with discretized covariates". The idea
#' is to compute just on the unique rows of X by also using an index vector to map to the original matrix.
#' The algorithm implemented here is a small adaption of the original algorithm. Instead of calculating $XW$
#' which again, needs to be transposed, we directly calculate $X^TW$ to avoid another transposing step. In addition
#' to the original algorithm the algorithm here directly calculates the crossproduct with the response.
#'
#' @param X [\code{arma::mat}]\cr
#'   Matrix X.
#' @param y [\code{arma::vec}]\cr
#'   Response vector y.
#' @param k [\code{arma::uvec}]\cr
#'   Index vector for mapping to original matrix $X_o(i,) = X(k(i),.)$.
#' @param w [\code{arma::vec}]\cr
#'   Vector of weights that are accumulated.
#' @return \code{arma::mat} Matrix Product $X^TWX$.
#' @examples
#' nsim = 1e6L
#' nunique = trunc(sqrt(nsim))
#'
#' xunique = runif(n = nunique, min = 0, max = 10)
#' k = sample(x = seq_len(nunique), size = nsim, replace = TRUE)
#'
#' X = poly(x = xunique, degree = 20L)
#' y = runif(nsim)
#'
#' binnedMatMultResponse(X = X, y = y, k = k-1, w = 1)
#' @export
binnedMatMultResponse <- function(X, y, k, w) {
    .Call(`_cpsp_binnedMatMultResponse`, X, y, k, w)
}

#' Calculating sparse binned matrix product
#'
#' This function calculates the matrix product (for sparse matrizes) using Algorithm 3 of Zheyuan Li, Simon N. Wood: "Faster
#' model matrix crossproducts for large generalized linear models with discretized covariates". The idea
#' is to compute just on the unique rows of X by also using an index vector to map to the original matrix.
#' The algorithm implemented here is a small adaption of the original algorithm. Instead of calculating $XW$
#' which again, needs to be transposed, we directly calculate $X^TW$ to avoid another transposing step.
#'
#' @param X [\code{arma::sp_mat}]\cr
#'   Matrix X.
#' @param k [\code{arma::uvec}]\cr
#'   Index vector for mapping to original matrix $X_o(i,) = X(k(i),.)$.
#' @param w [\code{arma::vec}]\cr
#'   Vector of weights that are accumulated.
#' @return \code{arma::mat} Matrix Product $X^TWX$.
#' @examples
#' nsim = 1e6L
#' nunique = trunc(sqrt(nsim))
#'
#' xunique = runif(n = nunique, min = 0, max = 10)
#' k = sample(x = seq_len(nunique), size = nsim, replace = TRUE)
#'
#' X = poly(x = xunique, degree = 20L)
#'
#' binnedMatMult(X = X, k = k-1, w = 1)
#' @export
binnedSparseMatMult <- function(X, k, w) {
    .Call(`_cpsp_binnedSparseMatMult`, X, k, w)
}

#' Calculating binned matrix product for response term for sparse matrices
#'
#' This function calculates the matrix product (sparse matrices) using Algorithm 3 of Zheyuan Li, Simon N. Wood: "Faster
#' model matrix crossproducts for large generalized linear models with discretized covariates". The idea
#' is to compute just on the unique rows of X by also using an index vector to map to the original matrix.
#' The algorithm implemented here is a small adaption of the original algorithm. Instead of calculating $XW$
#' which again, needs to be transposed, we directly calculate $X^TW$ to avoid another transposing step. In addition
#' to the original algorithm the algorithm here directly calculates the crossproduct with the response.
#'
#' @param X [\code{arma::sp_mat}]\cr
#'   Matrix X.
#' @param y [\code{arma::vec}]\cr
#'   Response vector y.
#' @param k [\code{arma::uvec}]\cr
#'   Index vector for mapping to original matrix $X_o(i,) = X(k(i),.)$.
#' @param w [\code{arma::vec}]\cr
#'   Vector of weights that are accumulated.
#' @return \code{arma::mat} Matrix Product $X^TWX$.
#' @examples
#' nsim = 1e6L
#' nunique = trunc(sqrt(nsim))
#'
#' xunique = runif(n = nunique, min = 0, max = 10)
#' k = sample(x = seq_len(nunique), size = nsim, replace = TRUE)
#'
#' X = poly(x = xunique, degree = 20L)
#' y = runif(nsim)
#'
#' binnedMatMultResponse(X = X, y = y, k = k-1, w = 1)
#' @export
binnedSparseMatMultResponse <- function(X, y, k, w) {
    .Call(`_cpsp_binnedSparseMatMultResponse`, X, y, k, w)
}

#' Calculate vector of bins of specific size
#'
#' This function returns a vector of equally spaced points of length n_bins.
#'
#' @param x [\code{arma::vec}]\cr
#'   Vector that should be discretized.
#' @param n_bins [\code{unsigned int}]\cr
#'   Number of unique points for binning the vector x.
#' @return \code{arma::vec} Vector of discretized x.
#' @examples
#' x = runif(100)
#' binVectorCustom(x, 10)
#' @export
binVectorCustom <- function(x, n_bins) {
    .Call(`_cpsp_binVectorCustom`, x, n_bins)
}

#' Calculate vector of bins
#'
#' This function returns a vector of equally spaced points of length the square root of the size of the vector.
#'
#' @param x [\code{arma::vec}]\cr
#'   Vector that should be discretized.
#' @return \code{arma::vec} Vector of discretized x.
#' @examples
#' x = runif(100)
#' binVector(x)
#' @export
binVector <- function(x) {
    .Call(`_cpsp_binVector`, x)
}

#' Calculate index vector for binned vector
#'
#' This function returns the indexes of the unique values to the complete binned vector.
#'
#' @param x [\code{arma::vec}]\cr
#'   Vector that should be discretized.
#' @param x_bins [\code{arma::vec}]\cr
#'   Vector of unique values for binning.
#' @return \code{arma::uvec} Index vector.
#' @examples
#' x = runif(10000)
#' bins = binVector(x)
#' idx = calculateIndexVector(x, bins)
#' head(data.frame(x = x, bins = bins[idx + 1]))
#' @export
calculateIndexVector <- function(x, x_bins) {
    .Call(`_cpsp_calculateIndexVector`, x, x_bins)
}

#' Subtract the basis of one matrix of another
#'
#' This function subtracts the basis of X2 from X1. The resulting
#' matrix is not able to reconstruct the basis of X2.
#' @param X1 [`matrix()`]\cr
#'   Matrix of rank p1 from which the X1 basis is subtracted.
#' @param X2 [`matrix()`]\cr
#'   Matrix of rank p2.
#' @return `matrix()` Matrix of rank p1-p2 with new basis
#' @examples
#' x = runif(100)
#' X1 = cbind(1, x, x^2, x^3, x^4)
#' X2 = cbind(1, x)
#' getSubtractionRotation(X1, X2)
#' @export
getSubtractionRotation <- function(X1, X2) {
    .Call(`_cpsp_getSubtractionRotation`, X1, X2)
}

#' Transform degrees of freedom to lambda
#'
#' This function calculates the Demmler-Reinsch-Orthogonalization to translate
#' the degrees of freedom to a penalty term.
#'
#' @param XtX [\code{matrix}]\cr
#'   Square matrix calculated by $X^TW^TWX$, where $X$ is the design matrix, and
#'   $W$ the diagonal matrix where the diagonal includes the weights.
#' @param penalty_mat [\code{matrix}]\cr
#'   Penalization matrix used for model fitting.
#' @param degrees_of_freedom [\code{numeric(1)}]\cr
#'   Degrees of freedom to convert to the penalty term.
#' @return \code{numeric(1)} Penalty term which corresponds to the given degrees of freedom.
#' @examples
#' X = cbind(1, iris$Petal.Length, iris$Sepal.Length)
#' weights = rep(1, nrow(iris))
#' pen = penaltyMat(ncol(X), 2)
#' XtX = t(X) %*% t(diag(weights)) %*% diag(weights) %*% X
#' 
#' demmlerReinsch(XtX, pen, 2)
#' @export
demmlerReinsch <- function(XtX, penalty_mat, degrees_of_freedom) {
    .Call(`_cpsp_demmlerReinsch`, XtX, penalty_mat, degrees_of_freedom)
}

#' Calculating penalty matrix
#' 
#' This function calculates the penalty matrix for a given number of 
#' parameters (`nparams`) and a given number of differences (`differences`).
#' 
#' @param nparams [\code{integer(1)}]\cr 
#'   Number of params which should be penalized.
#'   This also pretend the number of rows and columns.
#' @param differences [\code{integer(1)}]\cr 
#'   Number of penalized differences.//' 
#' @return \code{arma::sp_mat} Sparse penalty matrix used for p splines. 
#' @examples
#' pen = penaltyMat(10, 2)
#' @export
penaltyMat <- function(nparams, differences) {
    .Call(`_cpsp_penaltyMat`, nparams, differences)
}

#' Binary search to find index of given point within knots
#' 
#' This small functions search for the position of `x` within the
#' `knots` and returns the smalles index for which x >= knots[i].
#' 
#' Note that this function returns the `C++` index which starts 
#' with `0` and ends with `n-1`.
#'
#' @param x [\code{numeric(1)}]\cr 
#'   Point to search for position in knots.
#' @param knots [\code{numeric}]\cr 
#'   Vector of knots. It's the users responsibility to pass a sorted vector.
#' @return Index of position of \code{x} in `knots`.
#' @examples
#' knots = 1:10
#' findSpan(1, knots)
#' findSpan(2.5, knots)
#' findSpan(9.5, knots)
#' findSpan(10, knots)
#' @export
findSpan <- function(x, knots) {
    .Call(`_cpsp_findSpan`, x, knots)
}

#' Create knots for a specific number, degree and values
#' 
#' This functions takes a vector of points and creates knots used for the
#' splines depending on the number of knots and degree. This function just
#' handles equidistant knots.
#' 
#' @param values [\code{numeric}]\cr 
#'   Points to create the basis matrix.
#' @param n_knots [\code{integer(1)}]\cr 
#'   Number of innter knots.
#' @param degree [\code{integer(1)]}\cr 
#'   Polynomial degree of splines.
#' @return Vector of knots.
#' @examples
#' x = sort(runif(100, 0, 10))
#' y = 2 * sin(x) + rnorm(100, 0, 0.5)
#' 
#' # Create knots on the space of x:
#' knots = createKnots(values = x, n_knots = 7, degree = 3)
#' @export
createKnots <- function(values, n_knots, degree) {
    .Call(`_cpsp_createKnots`, values, n_knots, degree)
}

#' Transformation from a vector of input points to dense matrix of basis
#' 
#' This functions takes a vector of points and create a sparse matrix of
#' basis functions. Each row contains the basis of the corresponding value 
#' in `values`.
#' 
#' @param values [\code{numeric}]\cr 
#'   Points to create the basis matrix.
#' @param degree [\code{integer(1)}]\cr 
#'   Polynomial degree of splines.
#' @param knots [\code{numeric}]\cr 
#'   Vector of knots on which the splines are computed.
#' @return Vector of knots.
#' @examples
#' nsim = 100
#' x = sort(runif(nsim, 0, 10))
#' y = 2 * sin(x) + rnorm(nsim, 0, 0.5) 
#' knots = createKnots(values = x, n_knots = 20, degree = 3)
#'
#' # Create spline basis:
#' basis = createSplineBasis(values = x, degree = 3, knots = knots)
#' @export
createSplineBasis <- function(values, degree, knots) {
    .Call(`_cpsp_createSplineBasis`, values, degree, knots)
}

#' Transformation from a vector of input points to sparse matrix of basis
#' 
#' This functions takes a vector of points and create a sparse matrix of
#' basis functions. Each row contains the basis of the corresponding value 
#' in `values`.
#' 
#' @param values [\code{numeric}]\cr 
#'   Points to create the basis matrix.
#' @param degree [\code{integer(1)}]\cr 
#'   Polynomial degree of splines.
#' @param knots [\code{numeric}]\cr 
#'   Vector of knots on which the splines are computed.
#' @return Vector of knots.
#' @examples
#' nsim = 100
#' x = sort(runif(nsim, 0, 10))
#' y = 2 * sin(x) + rnorm(nsim, 0, 0.5) 
#' knots = createKnots(values = x, n_knots = 20, degree = 3)
#'
#' # Create spline basis:
#' basis = createSparseSplineBasis(values = x, degree = 3, knots = knots)
#' @export
createSparseSplineBasis <- function(values, degree, knots) {
    .Call(`_cpsp_createSparseSplineBasis`, values, degree, knots)
}

#' Calculating row wise tensor product
#'
#' This function calculates the row wise tensor product which can be used
#' for multivariate smoothing but also for modelling multivariate interactions.
#'
#' @param A [\code{matrix}]\cr
#'   First matrix for the tensor product.
#' @param B [\code{matrix}]\cr
#'   Second matrix for the tensor product.
#' @return \code{arma::mat} Tensor product
#' @examples
#' pen = penaltyMat(10, 2)
#' @export
rowWiseTensor <- function(A, B) {
    .Call(`_cpsp_rowWiseTensor`, A, B)
}

#' Calculating row wise tensor product for sparse matrices
#'
#' This function calculates the row wise tensor product which can be used
#' for multivariate smoothing but also for modelling multivariate interactions.
#'
#' @param A [\code{matrix}]\cr
#'   First sparse matrix for the tensor product.
#' @param B [\code{matrix}]\cr
#'   Second sparse matrix for the tensor product.
#' @return \code{arma::mat} Sparse tensor product
#' @examples
#' pen = penaltyMat(10, 2)
#' @export
rowWiseTensorSparse <- function(A, B) {
    .Call(`_cpsp_rowWiseTensorSparse`, A, B)
}

